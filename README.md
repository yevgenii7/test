<h3>Использовался Yii 2 Basic</h3>

### Развёртывание
- клонировать репозиторий и установить зависимости с помощь composer: </br>
git clone https://github.com/yevgenii7/test.git </br>
composer instal</br>
- прописать настройки соединения с бд и выполнить миграции </br>
php yii migrate</br>
- выполнить миграции необходимые для rbac</br>
php yii migrate --migrationPath=@yii/rbac/migrations</br>
- запустить скрипт для создания ролей (admin,manager,buyer) и привелегий (createOrder,viewOrder,changeOrderStatus,deleteOrder)</br>
php yii rbac/init</br>

Для проверки авторизации:
- нужно создать трёх пользователей с разными ролями (на странице Users)</br>
пользователь с ролью admin - будет иметь все права и привелегии над заказами</br>
пользователь с ролью manager - будет иметь право просматривать и изменять статус заказа</br>
пользователь с ролью buyer - будет иметь право создавать и удалять заказы</br>
(Если manager кликнет по кнопке удаления или создания заказа, то он просто будет редиректиться на страницу заказов)</br>
- Далее можно создать несколько заказов и проверить авторизацию для различных видов пользователей.</br>
- Также, на страницу /admin смогут зайти только залогинившиеся пользователи</br>

Вход:
Изначально в базовом шаблоне yii2 уже была модель User со своими полями и вход был выполнен без использования данных из таблицу user в бд.</br>
Переделал, чтобы пользователи проверялись в бд, но проверяется только имя (не стал заморачиваться с настройкой регистрации и входа). Т.е.</br> 
чтобы войти, достаточно правильно прописать имя пользователя, которые были созданны на предыдущем этапе.</br>

Проверка REST API с ЧПУ и интеграцией:
- сделал стандартно, как описано в документации</br>
Если пройти по /api/orders, то отдаётся xml списка заказов или в виде json в консоли </br>
 curl -i -H "Accept:application/json" "http://test/api/orders"</br>

Синхронизация с внешним сервисом (список товаров https://dummyjson.com/products):
- настроил получение товаров, с помощью консольной команды</br>
 php yii dummy-resource/index</br>
Её можно запускать через определённые промежутки времени по крону. Сейчас сделано так, что сначала таблица product в бд полностью очищается,</br> 
потом заполняется новыми данными. Если бы у каждого товара был допустим артикул, то можно было бы сравнивать каждый прищедший товар и обновлять </br>
точечно каждый товар.</br>

Блок "Сервис с DI и типизацией:"</br>
- "Реализовать интерфейс для сервиса и внедрение через DI-контейнер" - в принципе реализовал, хотя из-за версии php на локальном </br>
сервере (7.4) - не так, как хотелось бы. Использую xampp - там проблематично быстро переключиться на другую версию.</br>
- "Покрыть сервис unit-тестами (PHPUnit)" - создал тест для JsonDataParser сервиса (его метода), но к сожалению сам JsonDataParser изнутри тестового </br>
класса не находится (отдаётся ошибка).</br>

Блок "Роутинг и контроллеры:" - реализовал



### Задание 
CRUD с фильтрами и авторизацией:
- Создать CRUD для сущностей "Товары", "Заказы", "Пользователь" (MySQL, ActiveRecord);
- Реализовать фильтр поведения (RBAC) для ограничения доступа к редактированию (3 роли, администратор (Все права), 
менеджер(Только просмотр и изменение статуса заказа), покупатель (создать заказ));
- Добавить валидации и пред/пост-обработку данных (например, автоформатирование цены).
- 
REST API с ЧПУ и интеграцией:
- Разработать REST API (GET, POST, PUT, DELETE) для сущности "Заказы";
- Настроить urlManager для ЧПУ-ссылок (например, /order/123/view);
- Сделать синхронизацию с внешним сервисом (список товаров https://dummyjson.com/products).
Сервис с DI и типизацией:
- Написать компонент для обработки данных от внешнего сервиса (например, парсинг JSON);
- Реализовать интерфейс для сервиса и внедрение через DI-контейнер;
- Покрыть сервис unit-тестами (PHPUnit).
Роутинг и контроллеры:
- Создать цепочку контроллеров (например, AdminController → ProductController) для маршрута /admin/product/123/edit;
- Настроить роутинг через urlManager и обработку параметров;
- Добавить фильтр поведения для проверки прав доступа.

------------
